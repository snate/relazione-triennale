% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex
% !TEX spellcheck = it-IT

%**************************************************************
\chapter{Svolgimento dello stage}
\label{cap:progetto}
%**************************************************************

\intro{In questo capitolo verranno descritti i dettagli riguardanti
l'attività di stage.}\\

%**************************************************************
\section{Pianificazione}

Man mano che venivano definite, le attività pianificate di settimana in
settimana sono state inserite in JPA in sprint visibili solamente a me.

In questi sprint i task venivano creati da me e assegnati a me stesso,
utilizzando i tipi disponibili nel seguente modo:

\begin{itemize}
\item \textbf{Nuovo sviluppo:} documentazione
\item \textbf{Implementazione:} realizzazione di funzionalità
\item \textbf{Errore:} anomalie riportate dal tutor aziendale o dagli altri
  membri del team
\end{itemize}

Sebbene dalla quarta settimana fossero disponibili anche le checklist per
pianificare ed organizzare il proprio lavoro, non ho mai avuto necessità di
utilizzarle siccome gli sprint da me utilizzati erano personali. A causa
di ciò, anche decomponendo i task più complessi in un insieme di task, la
visualizzazione dello sprint rimaneva sempre chiara.

La pianificazione effettuata durante l'attività di stage ha raffinato gli
obiettivi ed il Piano di Lavoro inizialmente individuati.

Dal momento che durante lo stage alcune parti del lavoro previsto sono state
completate anticipatamente, sono stati aggiunti nuovi obiettivi produttivi ad
attività in corso.

Le deviazioni rispetto al Piano di Lavoro (tabella \ref{tab:piano-di-lavoro})
delle otto settimane lavorative di stage sono riportate in tabella
\ref{tab:deviazioni}.

Si può in particolare notare che la maggior parte del lavoro svolto nelle
settimane 5, 7 e 8 non era prevista inizialmente. Questi incrementi sono stati
concordati con il tutor aziendale durante la mia permanenza a Sanmarco
Informatica, analizzando ulteriori necessità del team.

\begin{tabular}[t]{| c | p{10cm} |}

\hline
\textbf{Settimana} & \textbf{Lavoro previsto} \\
\hline
1 &
Sviluppo di un layout alternativo per un modulo (non previsto). \\
\hline
2 &
Mancato sviluppo di creazione checklist da template (obbligatorio) e
  importazione template in checklist (opzionale). \\
\hline
3 &
Sviluppo creazione checklist da template (in ritardo dalla settimana 2). \\
\hline
4 &
Completamento modulo burn-down chart, documentazione esclusa. \\
\hline
5 &
Importazione di template in checklist (opzionale, in ritardo dalla settimana
  2). Completamento documentazione burn-down chart. Sviluppo avvio istanza da
  task Scrum (in anticipo, previsto per settimana 6). Sviluppo di ulteriori
  strumenti di Inspection: burn-up chart, pie chart, cumulative flow diagram e
  una variante del burn-down chart (inizialmente non previsti). \\
\hline
6 &
Analisi, sviluppo e documentazione sul collegamento tra modulo scrum e modulo
  di notifica (anticipato dalla settimana 7). \\
\hline
7 &
Analisi, sviluppo e documentazione sul collegamento tra modulo scrum e
  modulo forum (anticipato dalla settimana 8). Sviluppo di \gloss{api} per
  JPAUtil (inizialmente non previste). Implementazione di un nuovo tipo di
  notifica utilizzando un Telegram Bot. \\
\hline
8 &
Sviluppo di un sistema di gestione del collegamento tra il proprio utente e il
  proprio numero telefonico/account su Telegram. Sviluppo di un modulo di
  istruzioni per la creazione di un proprio Telegram Bot. Prototipazione di
  invio di documenti. Incremento in termini di sicurezza dell'accoppiamento tra
  un utente e il Telegram Bot. Studio della realtà aziendale e inizio stesura
  della relazione finale. \\
\hline
\end{tabular}
\captionof{table}{Deviazioni rispetto al Piano di Lavoro}
\label{tab:deviazioni}

\paragraph{Strumenti di \emph{Inspection}} \mbox{} \\

Un burn-down chart può non essere l'unico strumento di \emph{Inspection} utile
per un gruppo di lavoro, poichè non riesce a mostrare informazioni riguardo a
diversi indicatori di performance:

\begin{itemize}
\item Un \textbf{burn-up chart} mostra quante attività vengono aggiunte man
  mano che lo sprint avanza, mettendo in evidenza eventuali lacune
  nell'attività di pianificazione;
\item Un \textbf{cumulative flow diagram} mostra i livelli in cui risiedono
  maggiormente i task, trovando eventuali colli di bottiglia nei processi di
  sviluppo aziendale e permettendo di ricavare utili informazioni come il
  \gls{lead-time}.
\end{itemize}

\paragraph{Notifiche su Telegram} \mbox{} \\

Le funzionalità di notifica previste dal Piano di Lavoro riguardavano l'invio
di mail interne tramite un modulo di JPA dedicato a tale scopo.

Tuttavia, tale parte dell'applicazione è ancora in via di sviluppo e presenta
delle limitazioni come il fatto di non poter utilizzata al di fuori di JPA.

Per questo motivo, durante lo stage è stato concordato lo sviluppo di un nuovo
tipo di notifiche, trasmesse su Telegram.

Telegram è un programma di messaggistica istantanea completamente
gratuito\footnote{a differenza di altri software, anche le \gloss{api}
disponibili sono gratuite} che ha nella velocità e nella sicurezza i suoi
punti di forza. Questa applicazione è disponibile sia su dispositivi mobili
che su computer ed è permesso l'invio di qualsiasi tipo di file.

Dal 24 giugno di quest'anno Telegram ha reso disponibile i \textbf{Telegram
Bot}, ovvero degli account che ricevono e inviano messaggi via software e non
per comando diretto di persone.

Grazie a questi Bot è quindi possibile automatizzare attività e, nel caso del
mio stage, inviare messaggi contenenti notifiche relative ad eventi su JPA.

%**************************************************************
\section{Norme e strumenti}

\subsection{Formazione delle conoscenze mancanti}

Per formare le conoscenze mancanti ho proceduto sia con un apprendimento di
tipo ``classico'', consultando video on-line, libri e articoli di blog, sia con
un apprendimento di tipo pratico.

Questo mi ha permesso di conoscere Scrum, come i metodi agili sono collegati
al resto dei metodi di produzione industriali e di apprendere le
\gls{best-practice} per le tecnologie che non conoscevo.

\subsection{Comunicazione tra membri del team}

Le interazioni tra membri del team avvenivano tramite diversi mezzi di
comunicazione:

\begin{itemize}
\item Dialogo verbale, per chiarimenti veloci e di importanza minima e
  analisi. Gli esiti di questa venivano riportati per iscritto;
\item Telegram, per comunicazioni veloci di carattere generico;
\item Skype, per condivisione di file leggeri e link;
\item Forum di JPA, per la discussione di tematiche di sviluppo di interesse
  comune all'intero team;
\item Note su task in JPA, per aggiungere brevi notizie relative ad uno
  specifico task;
\item Mail interna a JPA, utilizzata solamente per le prime settimane di stage
  per comunicare l'ultimo numero del messaggio di errore per il lato client di
  JPA;
\item Mail personale (esterna a JPA), per comunicazioni di carattere formale.
\end{itemize}

\subsection{Sviluppo}

Le norme, le procedure e gli strumenti rispettati per lo sviluppo sono un
sovrainsieme di quanto elencato in sezione \ref{sec:azienda-tecnologie}.

In questa sezione verranno riportati i metodi e le regole che ho imposto a me
stesso durante lo sviluppo, facendo particolare attenzione che questi non
fossero conflittuali con quanto imposto dall'azienda.

\paragraph{Analisi} \mbox{} \\

L'attività di \textbf{analisi} serviva a delineare i requisiti e i possibili
scenari di applicazione per una funzionalità da introdurre.

Per quanto riguarda i requisiti, questi venivano divisi in:

\begin{itemize}
\item \textbf{Requisiti funzionali:} condizioni il cui soddisfacimento
  comportano un adempimento di una caratteristica comportamentale del sistema
  (e.g. aggiunta della funzionalità di modifica elemento);
\item \textbf{Requisiti non funzionali:} condizioni il cui soddisfacimento
  comporta un miglioramento della qualità d'uso del prodotto sviluppato (e.g.
  realizzazione del Manuale Utente).
\end{itemize}

I requisiti individuati venivano a loro volta frammentati fino a diventare di
granularità tale da poter monitorare con precisione il loro soddisfacimento,
per entrambi i tipi di requisito.

Per quanto riguarda i casi d'uso, questi venivano realizzati per poter
dialogare con minor ambiguità con il tutor aziendale riguardo gli obiettivi da
definire.

I casi d'uso sono stati utilizzati solamente per gli obiettivi più complessi,
esplicitando solamente le funzionalità più critiche di questi. Lo standard
adottato per la stesura di questi è \gloss{uml} 2.0.

\paragraph{Progettazione} \mbox{} \\

A seguito dell'analisi, vi è l'attività di \textbf{progettazione}.

JPA presenta un'architettura progettata per essere facilmente estensibile in
caso di modifiche di lieve entità: nella maggior parte dei casi,
l'implementazione di nuove funzionalità richiede la riproduzione di componenti
architetturali già esistenti, sia nel lato client che in quello server.

Per questo motivo, la progettazione per la maggior parte degli obiettivi è
consistita semplicemente nel:

\begin{itemize}
\item Progettare una o più nuove tabelle in JPADb o alterarne una di quelle
  già esistenti;
\item Definire delle classi che rappresentassero gli oggetti descritti nelle
  tabelle;
\item Stilare una lista di operazioni che il \BKEND{} deve offrire al \FREND{};
\item Nel caso in cui l'obiettivo preveda la realizzazione sul \FREND{} di un
  modulo o di una \gloss{direttiva}, progettarne uno (o una) sulla base di
  quelli già esistenti;
\item Progettazione della vista HTML e di quali operazioni questa può offrire
  all'utente.
\end{itemize}

Tuttavia, vi sono state delle eccezioni a questa procedura di progettazione.

La prima consiste nello sviluppo delle funzionalità di notifica: l'architettura
da progettare per questa parte doveva presentare un livello di complessità
maggiore affinchè di potesse essere estesa più facilmente in futuro.

Oltre a ciò, col passare delle settimane la mia conoscenza su AngularJS è
cresciuta con studi personali. Dopo aver lavorato per cinque settimane, ho
notato che il principio DRY\footnote{\emph{Don't Repeat Yourself}} non veniva
rispettato: molte parti di logica applicativa del lato client venivano
replicate in diversi moduli, sebbene fossero relative non a uno specifico
modulo, ma ad una componente specifica del dominio applicativo.

Per questo motivo, ho introdotto nell'architettura del \FREND{} degli
\emph{Angular service}, ovvero oggetti che potessero incapsulare delle
operazioni specifiche per un certo elemento del dominio applicativo (e.g.
collegamento tra area forum e uno sprint).

Con questo approccio, fin da subito ho avuto vantaggi significativi:

\begin{itemize}
\item \textbf{Diminuzione delle righe di codice:} molte parti di codice lunghe
  e ripetute sono state spostate esternamente ai moduli, alleggerendo questi;
\item \textbf{Costo delle modifiche:} anzichè dover cercare le sezioni di
  codice in cui le stesse istruzioni venivano eseguite, è stato sufficiente
  applicare una modifica al corpo dei \emph{service};
\item \textbf{Aderenza al \gls{framework}:} L'architettura di AngularJS è
  spesso definita come MVVM (\emph{Model-View-ViewModel}). Il controller e
  l'oggetto \texttt{\$scope} dovrebbero fornire solamente uno strato
  intermedio tra vista e modello (ViewModel). Nell'architettura del \FREND{}
  pre-esistente, il controller stesso aveva al suo interno l'intera
  \emph{business logic} e la parte di Model era completamente assente.
\end{itemize}

\paragraph{Codifica} \mbox{} \\

Una volta conclusa la progettazione, comincia l'attività di codifica. Per
questa attività sono state individuate regole aggiuntive rispetto a quelle già
impiegate dal team.

Per il \BKEND{} ho deciso di commentare con Javadoc ogni classe, campo dati o
metodo qualora il nome di questi non facesse già capire cosa rappresenta tale
entità.

Tale accorgimento è stato veramente utile, poichè molte classi presentavano
molti campi dati con nomi lunghi due o tre lettere (per motivi di efficienza)
e l'\gloss{ide}, senza Javadoc, non fornisce un aiuto contestuale per la loro
descrizione.

Se ad essere commentata è un'operazione, devono essere usate anche le
annotazioni \texttt{@param} e \texttt{@return} per spiegare quali parametri
fornire e cosa restituisce tale metodo.

Un altro accorgimento adottato per il \BKEND{} è far corrispondere ad ogni
variante di una classe enumerativa una stringa che la rappresenti.

Per il \FREND{} ho adottato le seguenti convenzioni:

\begin{itemize}
\item Per la dichiarazione di oggetti vuoti, inizializzarli dando come valore
  \texttt{\{\}};
\item Per la dichiarazione di vettori vuoti, inizializzarli dando come valore
  \texttt{[]};
\item Uso di JSDoc per i metodi più complessi;
\item Il nome di ciascun modulo con cui si raggruppano diversi servizi per
  poterli includere deve terminare con \texttt{Services}.
\end{itemize}

Oltre alle regole sopra elencate, per il \FREND{} ho deciso di versionare
autonomamente quanto producevo. Il \gloss{vcs} che ho scelto è \textbf{Git},
siccome avevo già esperienza con tale sistema.

Questo mi ha permesso di:

\begin{itemize}
\item avere un ramo principale (\texttt{master}) in cui sono presenti tutti
  gli incrementi per i vari obiettivi previsti dal Piano di Lavoro;
\item avere dei rami secondari per funzionalità il cui inserimento non
  garantiva stabilità (ad esempio quando ho inserito gli
  \emph{Angular service} ho creato un ramo apposito);
\item alla consegna del lavoro, ho potuto inviare al tutor aziendale una copia
  del \gls{repository} in cui vi è una sequenza di salvataggi
  sufficientemente o più granulare da poter separare la realizzazione di un
  obiettivo da un altro. In questo modo, l'inclusione dei vari
  incrementi è molto più semplice sia in termini di integrazione che di
  verifica;
\item avere una \emph{staging area}, in cui salvare temporaneamente e non
  definitivamente le modifiche, per poterle confermare in un secondo momento
  (al contrario di SVN, dove questa è assente).
\end{itemize}

\paragraph{Documentazione} \mbox{} \\

Per la documentazione ho utilizzato il linguaggio \LaTeX{}, \TeX{}Studio come
ambiente di scrittura e Inkscape per trattare le immagini da inserire.

I documenti possono essere:

\begin{itemize}
\item Manuali Utente;
\item Specifiche Tecniche;
\item Documenti generici.
\end{itemize}

Per ogni documento, ogni revisione deve essere indicata e, nel caso in cui vi
sia più di una revisione dello stesso documento, deve essere inserito un
diario delle modifiche.

Ciascun documento ha una sezione introduttiva, dove è indicato lo scopo del
documento, lo scopo del prodotto, istruzioni per la lettura del documento (ad
esempio vengono esplicitate eventuali convenzioni tipografiche o l'uso di
standard come \gloss{uml}) ed eventuali note di carattere generico.

In ciascun documento possiede un glossario, collocato nelle pagine finali e
avente contenuto specifico per il dominio applicativo trattato.

%**************************************************************
\section{Resoconto dell'attività di stage}

\subsection{Prima settimana -- formazione}

\subsection{Analisi}

\subsection{Progettazione}

\subsection{Codifica}

\subsection{Verifica ed integrazione}
